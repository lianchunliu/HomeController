###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         14/Oct/2017  22:53:27 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\HomeController\Components\hal\target\CC2530EB\h #
#                          al_key.c                                           #
#    Command line       =  -f C:\HomeController\Projects\zstack\Samples\Gener #
#                          icApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cf #
#                          g (-DCPU32MHZ -DROOT=__near_func -DBLINK_LEDS) -f  #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg  #
#                          (-DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR      #
#                          -DDEFAULT_CHANLIST=0x00004000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          C:\HomeController\Components\hal\target\CC2530EB\h #
#                          al_key.c -D ZIGBEEPRO -D NWK_AUTO_POLL -D          #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -D xPOWER_SAVING -lC        #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\EndDeviceEB-Pro\List\ -lA              #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\EndDeviceEB-Pro\List\ --diag_suppress  #
#                          Pe001,Pa010 -o C:\HomeController\Projects\zstack\S #
#                          amples\GenericApp\CC2530DB\EndDeviceEB-Pro\Obj\    #
#                          -e --debug --core=plain --dptr=16,1                #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I C:\HomeController\Projects\zstack\Samples\Gener #
#                          icApp\CC2530DB\ -I C:\HomeController\Projects\zsta #
#                          ck\Samples\GenericApp\CC2530DB\..\SOURCE\ -I       #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\ZMAIN\TI2530DB\ -I            #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MT\ -I       #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\INCLUDE\ #
#                           -I C:\HomeController\Projects\zstack\Samples\Gene #
#                          ricApp\CC2530DB\..\..\..\..\..\COMPONENTS\HAL\TARG #
#                          ET\CC2530EB\ -I C:\HomeController\Projects\zstack\ #
#                          Samples\GenericApp\CC2530DB\..\..\..\..\..\COMPONE #
#                          NTS\OSAL\MCU\CCSOC\ -I C:\HomeController\Projects\ #
#                          zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\OSAL\INCLUDE\ -I                        #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\AF\    #
#                          -I C:\HomeController\Projects\zstack\Samples\Gener #
#                          icApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\NWK #
#                          \ -I C:\HomeController\Projects\zstack\Samples\Gen #
#                          ericApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK\S #
#                          EC\ -I C:\HomeController\Projects\zstack\Samples\G #
#                          enericApp\CC2530DB\..\..\..\..\..\COMPONENTS\STACK #
#                          \SAPI\ -I C:\HomeController\Projects\zstack\Sample #
#                          s\GenericApp\CC2530DB\..\..\..\..\..\COMPONENTS\ST #
#                          ACK\SYS\ -I C:\HomeController\Projects\zstack\Samp #
#                          les\GenericApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          STACK\ZDO\ -I C:\HomeController\Projects\zstack\Sa #
#                          mples\GenericApp\CC2530DB\..\..\..\..\..\COMPONENT #
#                          S\ZMAC\F8W\ -I C:\HomeController\Projects\zstack\S #
#                          amples\GenericApp\CC2530DB\..\..\..\..\..\COMPONEN #
#                          TS\ZMAC\ -I C:\HomeController\Projects\zstack\Samp #
#                          les\GenericApp\CC2530DB\..\..\..\..\..\COMPONENTS\ #
#                          SERVICES\SADDR\ -I C:\HomeController\Projects\zsta #
#                          ck\Samples\GenericApp\CC2530DB\..\..\..\..\..\COMP #
#                          ONENTS\SERVICES\SDATA\ -I                          #
#                          C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\INCLUDE\ #
#                           -I C:\HomeController\Projects\zstack\Samples\Gene #
#                          ricApp\CC2530DB\..\..\..\..\..\COMPONENTS\MAC\HIGH #
#                          _LEVEL\ -I C:\HomeController\Projects\zstack\Sampl #
#                          es\GenericApp\CC2530DB\..\..\..\..\..\COMPONENTS\M #
#                          AC\LOW_LEVEL\srf04\ -I C:\HomeController\Projects\ #
#                          zstack\Samples\GenericApp\CC2530DB\..\..\..\..\..\ #
#                          COMPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\ -Ohz   #
#                          --require_prototypes                               #
#    List file          =  C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\EndDeviceEB-Pro\List\hal_key.lst       #
#    Object file        =  C:\HomeController\Projects\zstack\Samples\GenericA #
#                          pp\CC2530DB\EndDeviceEB-Pro\Obj\hal_key.r51        #
#                                                                             #
#                                                                             #
###############################################################################

C:\HomeController\Components\hal\target\CC2530EB\hal_key.c
      1          /**************************************************************************************************
      2            Filename:       hal_key.c
      3            Revised:        $Date: 2009-12-16 17:44:49 -0800 (Wed, 16 Dec 2009) $
      4            Revision:       $Revision: 21351 $
      5          
      6            Description:    This file contains the interface to the HAL KEY Service.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          /*********************************************************************
     40           NOTE: If polling is used, the hal_driver task schedules the KeyRead()
     41                 to occur every 100ms.  This should be long enough to naturally
     42                 debounce the keys.  The KeyRead() function remembers the key
     43                 state of the previous poll and will only return a non-zero
     44                 value if the key state changes.
     45          
     46           NOTE: If interrupts are used, the KeyRead() function is scheduled
     47                 25ms after the interrupt occurs by the ISR.  This delay is used
     48                 for key debouncing.  The ISR disables any further Key interrupt
     49                 until KeyRead() is executed.  KeyRead() will re-enable Key
     50                 interrupts after executing.  Unlike polling, when interrupts
     51                 are enabled, the previous key state is not remembered.  This
     52                 means that KeyRead() will return the current state of the keys
     53                 (not a change in state of the keys).
     54          
     55           NOTE: If interrupts are used, the KeyRead() fucntion is scheduled by
     56                 the ISR.  Therefore, the joystick movements will only be detected
     57                 during a pushbutton interrupt caused by S1 or the center joystick
     58                 pushbutton.
     59          
     60           NOTE: When a switch like S1 is pushed, the S1 signal goes from a normally
     61                 high state to a low state.  This transition is typically clean.  The
     62                 duration of the low state is around 200ms.  When the signal returns
     63                 to the high state, there is a high likelihood of signal bounce, which
     64                 causes a unwanted interrupts.  Normally, we would set the interrupt
     65                 edge to falling edge to generate an interrupt when S1 is pushed, but
     66                 because of the signal bounce, it is better to set the edge to rising
     67                 edge to generate an interrupt when S1 is released.  The debounce logic
     68                 can then filter out the signal bounce.  The result is that we typically
     69                 get only 1 interrupt per button push.  This mechanism is not totally
     70                 foolproof because occasionally, signal bound occurs during the falling
     71                 edge as well.  A similar mechanism is used to handle the joystick
     72                 pushbutton on the DB.  For the EB, we do not have independent control
     73                 of the interrupt edge for the S1 and center joystick pushbutton.  As
     74                 a result, only one or the other pushbuttons work reasonably well with
     75                 interrupts.  The default is the make the S1 switch on the EB work more
     76                 reliably.
     77          
     78          *********************************************************************/
     79          
     80          /**************************************************************************************************
     81           *                                            INCLUDES
     82           **************************************************************************************************/
     83          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x80
   \   union <unnamed> volatile __sfr _A_P0
   \                     _A_P0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x89
   \   unsigned char volatile __sfr P0IFG
   \                     P0IFG:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8c
   \   unsigned char volatile __sfr PICTL
   \                     PICTL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x8f
   \   unsigned char volatile __sfr P0INP
   \                     P0INP:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xab
   \   unsigned char volatile __sfr P0IEN
   \                     P0IEN:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe8
   \   union <unnamed> volatile __sfr _A_IRCON2
   \                     _A_IRCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf3
   \   unsigned char volatile __sfr P0SEL
   \                     P0SEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xfd
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1
     84          #include "hal_defs.h"
     85          #include "hal_types.h"
     86          #include "hal_board.h"
     87          #include "hal_drivers.h"
     88          #include "hal_adc.h"
     89          #include "hal_key.h"
     90          #include "osal.h"
     91          
     92          #include "user_printf.h"
     93          
     94          #if (defined HAL_KEY) && (HAL_KEY == TRUE)
     95          
     96          /**************************************************************************************************
     97           *                                              MACROS
     98           **************************************************************************************************/
     99          
    100          /**************************************************************************************************
    101           *                                            CONSTANTS
    102           **************************************************************************************************/
    103          #define HAL_KEY_RISING_EDGE   0
    104          #define HAL_KEY_FALLING_EDGE  1
    105          
    106          #define HAL_KEY_DEBOUNCE_VALUE  25
    107          #define HAL_KEY_POLLING_VALUE   100
    108          
    109          /* CPU port interrupt */
    110          #define HAL_KEY_CPU_PORT_0_IF P0IF
    111          #define HAL_KEY_CPU_PORT_2_IF P2IF
    112          
    113          
    114          
    115          /**************************************************************************************************
    116           *                                            TYPEDEFS
    117           **************************************************************************************************/
    118          
    119          
    120          /**************************************************************************************************
    121           *                                        GLOBAL VARIABLES
    122           **************************************************************************************************/

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    123          static uint8 halKeySavedKeys;     /* used to store previous key state in polling mode */
   \                     halKeySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    124          static uint8 mySavedKeys;
   \                     mySavedKeys:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    125          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    126          static halKeyCBack_t pHalKeyProcessFunction;
   \                     pHalKeyProcessFunction:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    127          static uint8 HalKeyConfigured;
   \                     HalKeyConfigured:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    128          bool Hal_KeyIntEnable;            /* interrupt enable/disable flag */
   \                     Hal_KeyIntEnable:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    129          
    130          /**************************************************************************************************
    131           *                                        FUNCTIONS - Local
    132           **************************************************************************************************/
    133          void halProcessKeyInterrupt(void);
    134          uint8 halGetJoyKeyInput(void);
    135          
    136          
    137          
    138          /**************************************************************************************************
    139           *                                        FUNCTIONS - API
    140           **************************************************************************************************/
    141          
    142          
    143          /**************************************************************************************************
    144           * @fn      HalKeyInit
    145           *
    146           * @brief   Initilize Key Service
    147           *
    148           * @param   none
    149           *
    150           * @return  None
    151           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    152          void HalKeyInit( void )
   \                     HalKeyInit:
    153          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    154            /* Initialize previous key to 0 */
    155            halKeySavedKeys = 0;
   \   000004   90....       MOV     DPTR,#halKeySavedKeys
   \   000007   E4           CLR     A
   \   000008   F0           MOVX    @DPTR,A
    156            mySavedKeys = 0;
   \   000009   90....       MOV     DPTR,#mySavedKeys
   \   00000C   F0           MOVX    @DPTR,A
    157          
    158            /* Initialize callback function */
    159            pHalKeyProcessFunction  = NULL;
   \   00000D   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
    160          
    161            /* Start with key is not configured */
    162            HalKeyConfigured = FALSE;
   \   000013   90....       MOV     DPTR,#HalKeyConfigured
   \   000016   F0           MOVX    @DPTR,A
    163          }
   \   000017                REQUIRE ?Subroutine0
   \   000017                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    164          
    165          
    166          /**************************************************************************************************
    167           * @fn      HalKeyConfig
    168           *
    169           * @brief   Configure the Key serivce
    170           *
    171           * @param   interruptEnable - TRUE/FALSE, enable/disable interrupt
    172           *          cback - pointer to the CallBack function
    173           *
    174           * @return  None
    175           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    176          void HalKeyConfig (bool interruptEnable, halKeyCBack_t cback)
   \                     HalKeyConfig:
    177          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
    178            /* Enable/Disable Interrupt or */
    179            Hal_KeyIntEnable = interruptEnable;
   \   000006   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000009   F0           MOVX    @DPTR,A
    180          
    181            /* Register the callback fucntion */
    182            pHalKeyProcessFunction = cback;
   \   00000A   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   00000D   EA           MOV     A,R2
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   EB           MOV     A,R3
   \   000011   F0           MOVX    @DPTR,A
    183          
    184            /* Determine if interrupt is enable or not */
    185            if (Hal_KeyIntEnable)
   \   000012   90....       MOV     DPTR,#Hal_KeyIntEnable
   \   000015   E0           MOVX    A,@DPTR
   \   000016   602D         JZ      ??HalKeyConfig_0
    186            {
    187              printf("INT keys\n");
   \   000018                ; Setup parameters for call to function printf
   \   000018   7A..         MOV     R2,#`?<Constant "INT keys\\n">` & 0xff
   \   00001A   7B..         MOV     R3,#(`?<Constant "INT keys\\n">` >> 8) & 0xff
   \   00001C   12....       LCALL   ??printf?relay
    188              
    189              /* Rising/Falling edge configuratinn */    
    190              
    191              /*
    192              P0INP  &= ~0X10;
    193              P0IEN |= 0x10;    // P0.4 设置为中断方式 1：中断使能
    194              PICTL |= 0x10;    //下降沿触发   
    195              IEN1 |= 0x20;    //允许P0口中断; 
    196              P0IFG |= 0x00;    //初始化中断标志位
    197             // EA = 1;          //打开总中断
    198              */
    199              P0INP  &= ~0X10;   //设置P0口输入电路模式为上拉/ 下拉
   \   00001F   538FEF       ANL     0x8f,#0xef
    200                  P0IEN |= 0X10;     //P01设置为中断方式 
   \   000022   43AB10       ORL     0xab,#0x10
    201                  PICTL |= 0X10;     // 下降沿触发     
   \   000025   438C10       ORL     0x8c,#0x10
    202             IEN1 |= 0X20;      //  开P0口总中断 
   \   000028   D2BD         SETB    0xb8.5
    203                  P0IFG |= 0x00;     //清中断标志
   \   00002A   858989       MOV     0x89,0x89
    204          	EA = 1; 
   \   00002D   D2AF         SETB    0xa8.7
    205                  
    206              /* Do this only after the hal_key is configured - to work with sleep stuff */
    207              if (HalKeyConfigured == TRUE)
   \   00002F   90....       MOV     DPTR,#HalKeyConfigured
   \   000032   E0           MOVX    A,@DPTR
   \   000033   6401         XRL     A,#0x1
   \   000035   7042         JNZ     ??HalKeyConfig_1
    208              {
    209                osal_stop_timerEx( Hal_TaskID, HAL_KEY_EVENT);  /* Cancel polling if active */
   \   000037                ; Setup parameters for call to function osal_stop_timerEx
   \   000037   7A01         MOV     R2,#0x1
   \   000039   7B00         MOV     R3,#0x0
   \   00003B   90....       MOV     DPTR,#Hal_TaskID
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   F9           MOV     R1,A
   \   000040   12....       LCALL   ??osal_stop_timerEx?relay
   \   000043   8034         SJMP    ??HalKeyConfig_1
    210              }
    211            }
    212            else    /* Interrupts NOT enabled */
    213            {
    214             
    215              P0SEL &= ~0x10;     //设置P0.4为普通IO口  
   \                     ??HalKeyConfig_0:
   \   000045   53F3EF       ANL     0xf3,#0xef
    216              P0DIR &= ~0x10;     //按键接在P0.4口上，设P0.4为输入模式 
   \   000048   53FDEF       ANL     0xfd,#0xef
    217              P0INP &= ~0x10;     //打开P0.4上拉电阻
   \   00004B   538FEF       ANL     0x8f,#0xef
    218              
    219              P0SEL &= ~0x20;     //设置P0.5为普通IO口  
   \   00004E   53F3DF       ANL     0xf3,#0xdf
    220              P0DIR &= ~0x20;     //按键接在P0.5口上，设P0.5为输入模式 
   \   000051   53FDDF       ANL     0xfd,#0xdf
    221              P0INP &= ~0x20;     //打开P0.5上拉电阻
   \   000054   538FDF       ANL     0x8f,#0xdf
    222              
    223              P0SEL &= ~0x40;     //设置P0.6为普通IO口  
   \   000057   53F3BF       ANL     0xf3,#0xbf
    224              P0DIR &= ~0x40;     //按键接在P0.6口上，设P0.6为输入模式 
   \   00005A   53FDBF       ANL     0xfd,#0xbf
    225              P0INP &= ~0x40;     //P0.6 
   \   00005D   538FBF       ANL     0x8f,#0xbf
    226             
    227              P0SEL &= ~0x80;     //设置P0.7为普通IO口  
   \   000060   53F37F       ANL     0xf3,#0x7f
    228              P0DIR &= ~0x80;     //按键接在P0.7口上，设P0.7为输入模式 
   \   000063   53FD7F       ANL     0xfd,#0x7f
    229              P0INP &= ~0x80;     //P0.7 
   \   000066   538F7F       ANL     0x8f,#0x7f
    230            
    231              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_POLLING_VALUE);    /* Kick off polling */
   \   000069                ; Setup parameters for call to function osal_start_timerEx
   \   000069   7C64         MOV     R4,#0x64
   \   00006B   7D00         MOV     R5,#0x0
   \   00006D   7A01         MOV     R2,#0x1
   \   00006F   7B00         MOV     R3,#0x0
   \   000071   90....       MOV     DPTR,#Hal_TaskID
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F9           MOV     R1,A
   \   000076   12....       LCALL   ??osal_start_timerEx?relay
    232            }
    233          
    234            /* Key now is configured */
    235            HalKeyConfigured = TRUE;
   \                     ??HalKeyConfig_1:
   \   000079   90....       MOV     DPTR,#HalKeyConfigured
   \   00007C   7401         MOV     A,#0x1
   \   00007E   F0           MOVX    @DPTR,A
    236          }
   \   00007F   FF           MOV     R7,A
   \   000080   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000083                REQUIRE P0INP
   \   000083                REQUIRE P0IEN
   \   000083                REQUIRE PICTL
   \   000083                REQUIRE _A_IEN1
   \   000083                REQUIRE P0IFG
   \   000083                REQUIRE _A_IEN0
   \   000083                REQUIRE P0SEL
   \   000083                REQUIRE P0DIR
    237          
    238          
    239          /**************************************************************************************************
    240           * @fn      HalKeyRead
    241           *
    242           * @brief   Read the current value of a key
    243           *
    244           * @param   None
    245           *
    246           * @return  keys - current keys status
    247           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    248          uint8 HalKeyRead ( void )
   \                     HalKeyRead:
    249          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    250            uint8 keys = 0;
    251            
    252            if (P0_4)//S1 
   \   000000   A284         MOV     C,0x80.4
   \   000002   5004         JNC     ??HalKeyRead_0
    253            {
    254              keys |= HAL_KEY_1_HIGH; 
   \   000004   7902         MOV     R1,#0x2
   \   000006   8002         SJMP    ??HalKeyRead_1
    255            } else {
    256              keys |= HAL_KEY_1_LOW;
   \                     ??HalKeyRead_0:
   \   000008   7901         MOV     R1,#0x1
    257            }
    258            
    259            
    260            if (P0_5)//S2 
   \                     ??HalKeyRead_1:
   \   00000A   A285         MOV     C,0x80.5
   \   00000C   E9           MOV     A,R1
   \   00000D   5004         JNC     ??HalKeyRead_2
    261            {
    262              keys |= HAL_KEY_2_HIGH; 
   \   00000F   D2E3         SETB    0xE0 /* A   */.3
   \   000011   8002         SJMP    ??HalKeyRead_3
    263            } else {
    264              keys |= HAL_KEY_2_LOW;
   \                     ??HalKeyRead_2:
   \   000013   D2E2         SETB    0xE0 /* A   */.2
   \                     ??HalKeyRead_3:
   \   000015   F9           MOV     R1,A
    265            }
    266          
    267            
    268            if (P0_6)
   \   000016   A286         MOV     C,0x80.6
   \   000018   E9           MOV     A,R1
   \   000019   5004         JNC     ??HalKeyRead_4
    269            {
    270              keys |= HAL_KEY_3_HIGH; 
   \   00001B   D2E5         SETB    0xE0 /* A   */.5
   \   00001D   8002         SJMP    ??HalKeyRead_5
    271            } else {
    272              keys |= HAL_KEY_3_LOW; 
   \                     ??HalKeyRead_4:
   \   00001F   D2E4         SETB    0xE0 /* A   */.4
   \                     ??HalKeyRead_5:
   \   000021   F9           MOV     R1,A
    273            }
    274            
    275            
    276            if (P0_7)
   \   000022   A287         MOV     C,0x80.7
   \   000024   E9           MOV     A,R1
   \   000025   5004         JNC     ??HalKeyRead_6
    277            {
    278              keys |= HAL_KEY_4_HIGH; 
   \   000027   D2E7         SETB    0xE0 /* A   */.7
   \   000029   8002         SJMP    ??HalKeyRead_7
    279            } else {
    280              keys |= HAL_KEY_4_LOW; 
   \                     ??HalKeyRead_6:
   \   00002B   D2E6         SETB    0xE0 /* A   */.6
   \                     ??HalKeyRead_7:
   \   00002D   F9           MOV     R1,A
    281            }
    282            
    283            return keys;
   \   00002E   02....       LJMP    ?BRET
   \   000031                REQUIRE _A_P0
    284          }
    285          
    286          uint8 diffKeys(uint8 savedKeys, uint8  keys);
    287          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    288          uint8 diffKeys(uint8 savedKeys, uint8  keys)
   \                     diffKeys:
    289          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FB           MOV     R3,A
    290            uint8 ret = 0;
   \   000007   7900         MOV     R1,#0x0
    291            for (int i = 0; i < 8; i++) {
   \   000009   7C00         MOV     R4,#0x0
   \   00000B   7D00         MOV     R5,#0x0
    292              uint8 savedKeyBit =  savedKeys & (1 << i);
    293              uint8 keyBit =  keys & (1 << i);
   \                     ??diffKeys_0:
   \   00000D   75..01       MOV     ?V0 + 0,#0x1
   \   000010   75..00       MOV     ?V0 + 1,#0x0
   \   000013   EC           MOV     A,R4
   \   000014   78..         MOV     R0,#?V0 + 0
   \   000016   12....       LCALL   ?S_SHL
   \   000019   A8..         MOV     R0,?V0 + 0
   \   00001B   EA           MOV     A,R2
   \   00001C   58           ANL     A,R0
   \   00001D   FE           MOV     R6,A
    294              if (keyBit && !savedKeyBit) {
   \   00001E   6008         JZ      ??diffKeys_1
   \   000020   EB           MOV     A,R3
   \   000021   58           ANL     A,R0
   \   000022   7004         JNZ     ??diffKeys_1
    295                ret |=  keyBit;
   \   000024   EE           MOV     A,R6
   \   000025   C9           XCH     A,R1
   \   000026   49           ORL     A,R1
   \   000027   F9           MOV     R1,A
    296              }
    297            }
   \                     ??diffKeys_1:
   \   000028   EC           MOV     A,R4
   \   000029   2401         ADD     A,#0x1
   \   00002B   0C           INC     R4
   \   00002C   ED           MOV     A,R5
   \   00002D   3400         ADDC    A,#0x0
   \   00002F   FD           MOV     R5,A
   \   000030   C3           CLR     C
   \   000031   EC           MOV     A,R4
   \   000032   9408         SUBB    A,#0x8
   \   000034   ED           MOV     A,R5
   \   000035   9400         SUBB    A,#0x0
   \   000037   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000039   65D0         XRL     A,PSW
   \   00003B   33           RLC     A
   \   00003C   40CF         JC      ??diffKeys_0
    298            
    299            return ret;
   \   00003E   7F02         MOV     R7,#0x2
   \   000040   02....       LJMP    ?BANKED_LEAVE_XDATA
    300          }
    301          /**************************************************************************************************
    302           * @fn      HalKeyPoll
    303           *
    304           * @brief   Called by hal_driver to poll the keys
    305           *
    306           * @param   None
    307           *
    308           * @return  None
    309           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    310          void HalKeyPoll (void)
   \                     HalKeyPoll:
    311          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    312            uint8 keys = HalKeyRead();
   \   000005                ; Setup parameters for call to function HalKeyRead
   \   000005   12....       LCALL   ??HalKeyRead?relay
   \   000008   E9           MOV     A,R1
   \   000009   FE           MOV     R6,A
    313            
    314           // if (!Hal_KeyIntEnable)
    315            {
    316              if (keys == mySavedKeys)
   \   00000A   90....       MOV     DPTR,#mySavedKeys
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6E           XRL     A,R6
   \   00000F   6031         JZ      ??HalKeyPoll_0
    317              {
    318                /* Exit - since no keys have changed */
    319                return;
    320              }
    321              /* Store the current keys for comparation next time */
    322              halKeySavedKeys = diffKeys(mySavedKeys, keys);
   \   000011                ; Setup parameters for call to function diffKeys
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??diffKeys?relay
   \   000018   E9           MOV     A,R1
   \   000019   90....       MOV     DPTR,#halKeySavedKeys
   \   00001C   F0           MOVX    @DPTR,A
    323              mySavedKeys = keys;
   \   00001D   EE           MOV     A,R6
   \   00001E   90....       MOV     DPTR,#mySavedKeys
   \   000021   F0           MOVX    @DPTR,A
    324            }
    325           
    326            /* Invoke Callback if new keys were depressed */
    327            if (keys && (pHalKeyProcessFunction))
   \   000022   601E         JZ      ??HalKeyPoll_0
   \   000024   90....       MOV     DPTR,#pHalKeyProcessFunction
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
   \   00002C   E8           MOV     A,R0
   \   00002D   49           ORL     A,R1
   \   00002E   6012         JZ      ??HalKeyPoll_0
    328            {
    329              (pHalKeyProcessFunction) (halKeySavedKeys, HAL_KEY_STATE_NORMAL);
   \   000030                ; Setup parameters for indirect call
   \   000030   7A00         MOV     R2,#0x0
   \   000032   90....       MOV     DPTR,#halKeySavedKeys
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037   90....       MOV     DPTR,#pHalKeyProcessFunction + 1
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F583         MOV     DPH,A
   \   00003D   8882         MOV     DPL,R0
   \   00003F   12....       LCALL   ?CALL_IND
   \                     ??HalKeyPoll_0:
   \   000042   7F01         MOV     R7,#0x1
   \   000044   02....       LJMP    ?BANKED_LEAVE_XDATA
    330            }
    331          }
    332          
    333          
    334          
    335          
    336          /**************************************************************************************************
    337           * @fn      halProcessKeyInterrupt
    338           *
    339           * @brief   Checks to see if it's a valid key interrupt, saves interrupt driven key states for
    340           *          processing by HalKeyRead(), and debounces keys by scheduling HalKeyRead() 25ms later.
    341           *
    342           * @param
    343           *
    344           * @return
    345           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    346          void halProcessKeyInterrupt (void)
   \                     halProcessKeyInterrupt:
    347          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    348            bool valid=TRUE;
    349            
    350          
    351            if (valid)
    352            {
    353              osal_start_timerEx (Hal_TaskID, HAL_KEY_EVENT, HAL_KEY_DEBOUNCE_VALUE);
   \   000004                ; Setup parameters for call to function osal_start_timerEx
   \   000004   7C19         MOV     R4,#0x19
   \   000006   7D00         MOV     R5,#0x0
   \   000008   7A01         MOV     R2,#0x1
   \   00000A   7B00         MOV     R3,#0x0
   \   00000C   90....       MOV     DPTR,#Hal_TaskID
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F9           MOV     R1,A
   \   000011   12....       LCALL   ??osal_start_timerEx?relay
    354            }
    355          }
   \   000014   02....       LJMP    ?Subroutine0 & 0xFFFF
    356          
    357          /**************************************************************************************************
    358           * @fn      HalKeyEnterSleep
    359           *
    360           * @brief  - Get called to enter sleep mode
    361           *
    362           * @param
    363           *
    364           * @return
    365           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    366          void HalKeyEnterSleep ( void )
   \                     HalKeyEnterSleep:
    367          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    368          }
   \   000000   02....       LJMP    ?BRET
    369          
    370          /**************************************************************************************************
    371           * @fn      HalKeyExitSleep
    372           *
    373           * @brief   - Get called when sleep is over
    374           *
    375           * @param
    376           *
    377           * @return  - return saved keys
    378           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    379          uint8 HalKeyExitSleep ( void )
   \                     HalKeyExitSleep:
    380          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    381            /* Wake up and read keys */
    382            return ( HalKeyRead () );
   \   000004                ; Setup parameters for call to function HalKeyRead
   \   000004   12....       LCALL   ??HalKeyRead?relay
   \   000007   02....       LJMP    ?Subroutine0 & 0xFFFF
    383          }
    384          
    385          /***************************************************************************************************
    386           *                                    INTERRUPT SERVICE ROUTINE
    387           ***************************************************************************************************/
    388          void SysPowerMode(uint8 mode);
    389          /**************************************************************************************************
    390           * @fn      halKeyPort0Isr
    391           *
    392           * @brief   Port0 ISR
    393           *
    394           * @param
    395           *
    396           * @return
    397           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    398          HAL_ISR_FUNCTION( halKeyPort0Isr, P0INT_VECTOR )
   \                     halKeyPort0Isr:
    399          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 14
   \   000007                ; Auto size: 0
    400            
    401            printf("hal isr key\n");
   \   000007                ; Setup parameters for call to function printf
   \   000007   7A..         MOV     R2,#`?<Constant "hal isr key\\n">` & 0xff
   \   000009   7B..         MOV     R3,#(`?<Constant "hal isr key\\n">` >> 8) & 0xff
   \   00000B   12....       LCALL   ??printf?relay
    402            
    403            halProcessKeyInterrupt();
   \   00000E                ; Setup parameters for call to function halProcessKeyInterrupt
   \   00000E   12....       LCALL   ??halProcessKeyInterrupt?relay
    404            
    405            SysPowerMode(4);
   \   000011                ; Setup parameters for call to function SysPowerMode
   \   000011   7904         MOV     R1,#0x4
   \   000013   12....       LCALL   ??SysPowerMode?relay
    406            
    407            P0IFG = 0;       //清中断标志 
   \   000016   758900       MOV     0x89,#0x0
    408            P0IF = 0;        //清中断标志  
   \   000019   C2C5         CLR     0xc0.5
    409              
    410          }
   \   00001B   7F01         MOV     R7,#0x1
   \   00001D   02....       LJMP    ?INTERRUPT_LEAVE_XSP
   \   000020                REQUIRE P0IFG
   \   000020                REQUIRE _A_IRCON
    411          
    412          
    413          /**************************************************************************************************
    414           * @fn      halKeyPort2Isr
    415           *
    416           * @brief   Port2 ISR
    417           *
    418           * @param
    419           *
    420           * @return
    421           **************************************************************************************************/

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    422          HAL_ISR_FUNCTION( halKeyPort2Isr, P2INT_VECTOR )
   \                     halKeyPort2Isr:
    423          {
   \   000000                ; Saved register size: 1
   \   000000                ; Auto size: 0
    424            HAL_KEY_CPU_PORT_2_IF = 0;
   \   000000   C2E8         CLR     0xe8.0
    425          }
   \   000002   32           RETI
   \   000003                REQUIRE _A_IRCON2

   \                                 In  segment INTVEC, offset 0x33, root
   \                     `??halKeyPort2Isr??INTVEC 51`:
   \   000033   02....       LJMP       (halKeyPort2Isr)

   \                                 In  segment INTVEC, offset 0x6b, root
   \                     `??halKeyPort0Isr??INTVEC 107`:
   \   00006B   02....       LJMP       (halKeyPort0Isr)

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??diffKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    diffKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyPoll?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyPoll

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halProcessKeyInterrupt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halProcessKeyInterrupt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyEnterSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyEnterSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalKeyExitSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalKeyExitSleep

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "INT keys\\n">`:
   \   000000   494E5420     DB "INT keys\012"
   \            6B657973
   \            0A00    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "hal isr key\\n">`:
   \   000000   68616C20     DB "hal isr key\012"
   \            69737220
   \            6B65790A
   \            00      
    426          
    427          #else
    428          
    429          
    430          void HalKeyInit(void){}
    431          void HalKeyConfig(bool interruptEnable, halKeyCBack_t cback){}
    432          uint8 HalKeyRead(void){ return 0;}
    433          void HalKeyPoll(void){}
    434          
    435          #endif /* HAL_KEY */
    436          
    437          
    438          
    439          
    440          
    441          /**************************************************************************************************
    442          **************************************************************************************************/
    443          
    444          
    445          

   Maximum stack usage in bytes:

     Function                    ISTACK PSTACK XSTACK
     --------                    ------ ------ ------
     HalKeyConfig                    0      0      9
       -> printf                     0      0     18
       -> osal_stop_timerEx          0      0     18
       -> osal_start_timerEx         0      0     18
     HalKeyEnterSleep                0      0      0
     HalKeyExitSleep                 2      0      0
       -> HalKeyRead                 4      0      0
     HalKeyInit                      2      0      0
     HalKeyPoll                      0      0      9
       -> HalKeyRead                 0      0     18
       -> diffKeys                   0      0     18
     HalKeyRead                      0      0      9
     diffKeys                        0      0     19
     halKeyPort0Isr                  0      0     14
       -> printf                     0      0     28
       -> halProcessKeyInterrupt     0      0     28
       -> SysPowerMode               0      0     28
     halKeyPort2Isr                  1      0      0
     halProcessKeyInterrupt          2      0     14
       -> osal_start_timerEx         4      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     _A_P0                             1
     P0IFG                             1
     PICTL                             1
     P0INP                             1
     _A_IEN0                           1
     P0IEN                             1
     _A_IEN1                           1
     _A_IRCON                          1
     _A_IRCON2                         1
     P0SEL                             1
     P0DIR                             1
     halKeySavedKeys                   1
     mySavedKeys                       1
     pHalKeyProcessFunction            2
     HalKeyConfigured                  1
     Hal_KeyIntEnable                  1
     HalKeyInit                       23
     ?Subroutine0                      7
     HalKeyConfig                    131
     HalKeyRead                       49
     diffKeys                         67
     HalKeyPoll                       71
     halProcessKeyInterrupt           23
     HalKeyEnterSleep                  3
     HalKeyExitSleep                  10
     halKeyPort0Isr                   32
     halKeyPort2Isr                    3
     ??halKeyPort2Isr??INTVEC 51       3
     ??halKeyPort0Isr??INTVEC 107      3
     ??HalKeyInit?relay                6
     ??HalKeyConfig?relay              6
     ??HalKeyRead?relay                6
     ??diffKeys?relay                  6
     ??HalKeyPoll?relay                6
     ??halProcessKeyInterrupt?relay    6
     ??HalKeyEnterSleep?relay          6
     ??HalKeyExitSleep?relay           6
     ?<Constant "INT keys\n">         10
     ?<Constant "hal isr key\n">      13

 
 384 bytes in segment BANKED_CODE
  48 bytes in segment BANK_RELAYS
   6 bytes in segment INTVEC
  35 bytes in segment NEAR_CODE
  11 bytes in segment SFR_AN
  23 bytes in segment XDATA_ROM_C
   6 bytes in segment XDATA_Z
 
 467 bytes of CODE  memory (+  6 bytes shared)
  23 bytes of CONST memory
   0 bytes of DATA  memory (+ 11 bytes shared)
   6 bytes of XDATA memory

Errors: none
Warnings: none
